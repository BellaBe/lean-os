skeleton:
  type: fastapi-microservice
  version: "2.0"
  
  components:
    required:
      - api          # FastAPI routers
      - services     # Business logic
      - repositories # Data access
      - schemas      # DTOs
      - db           # Models + session
      - events       # Publishers + listeners
      - observability # Metrics + tracing
      - config       # Configuration
      - dependencies # DI
      - exceptions   # Domain exceptions
      - lifecycle    # Startup/shutdown
      - main         # FastAPI app
    
    optional:
      - helpers      # Domain-specific helpers
      - utils        # Service-specific utilities
  
  shared_dependencies:
    api:
      - shared.api.responses           # success_response(), error_response()
      - shared.api.middleware          # Auth, CORS, correlation, logging
      - shared.api.dependencies        # RequestContextDep, ClientAuthDep
      - shared.api.handlers            # Exception handlers
      - shared.api.health              # Health check router
    
    messaging:
      - shared.messaging.jetstream_client  # NATS client
      - shared.messaging.publisher         # Base publisher
      - shared.messaging.listener          # Base listener
      - shared.messaging.subjects          # Subject patterns
      - shared.messaging.events.base       # BaseIdentifiers, BasePayload
    
    observability:                         
      - shared.observability.metrics       # MetricsCollector base
      - shared.observability.tracing       # TracingProvider base
      - shared.observability.logging       # Structured logging
      - shared.observability.monitors      # Composition monitors
    
    database:
      - shared.database.base               # Base, metadata
      - shared.database.mixins             # TimestampMixin, etc
      - shared.database.types              # Custom types
    
    utils:
      - shared.utils.exceptions            # Exception hierarchy
      - shared.utils.logger                # ServiceLogger
      - shared.utils.idempotency          # Idempotency handling
      - shared.utils.retry                 # Retry decorators
      - shared.utils.validation            # Validators
  
  patterns:
    service:
      signature: |
        class {Domain}Service:
            def __init__(
                self,
                session_factory: async_sessionmaker,
                publisher: {Domain}EventPublisher,
                logger: ServiceLogger,
                tracer: ServiceTracer,          
                metrics: ServiceMetrics          
            ):
                ...
            
            async def {method}(self, data: {Input}, ctx: RequestContext) -> {Output}:
                with self.tracer.start_span("{method}"):
                    self.metrics.increment("{method}_called")
                    async with self.session_factory() as session:
                        # ... composition from map
    
    event_publisher:                            
      signature: |
        class {Domain}EventPublisher(Publisher):
            @property
            def service_name(self) -> str:
                return "{domain}-service"
            
            async def {domain}_{event}(self, entity: {Domain}Out, ctx) -> str:
                payload = {...}
                return await self.publish_event(
                    subject=Subjects.{DOMAIN}_{EVENT},
                    payload=payload,
                    correlation_id=ctx.correlation_id
                )
    
    event_listener:                             
      signature: |
        class {Event}Listener(Listener):
            @property
            def subject(self) -> str:
                return "evt.{subject}.{event}.v1"
            
            @property
            def queue_group(self) -> str:
                return "{domain}-{event}"
            
            async def on_message(self, data: dict) -> None:
                # ... process event
            
            async def on_error(self, error: Exception, data: dict) -> bool:
                # ... handle error, send to DLQ if needed
    
    observability_metrics:                      
      signature: |
        class {Domain}Metrics(MetricsCollector):
            def __init__(self):
                super().__init__(service_name="{domain}-service")
                self.operation_counter = self.counter(...)
                self.duration_histogram = self.histogram(...)
    
    observability_tracer:                       
      signature: |
        class {Domain}Tracer(TracingProvider):
            def __init__(self):
                super().__init__(service_name="{domain}-service")
            
            def trace_{operation}(self, data):
                return self.start_span(...)
  
  contracts:
    responses:
      - Always use: shared.api.success_response()
      - Always use: shared.api.paginated_response()
      - Never use: shared.api.error_response() (middleware only)
    
    exceptions:
      - Never catch in endpoints
      - Raise typed exceptions from shared.utils.exceptions
      - Middleware renders error responses
    
    correlation:
      - Always propagate: correlation_id, request_id
      - Include in: all logs, all events, all traces
    
    events:                                     
      - Subject pattern: evt.{domain}.{action}.v1
      - Use queue groups: {domain}-{event}
      - DLQ pattern: dlq.{service}.{queue}.failed
      - Always propagate: correlation_id
    
    observability:                              
      - Trace all service methods
      - Metric all operations (counters, histograms)
      - Log with structured context
      - Monitor composition laws at runtime
